# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Multi-Agent Governance Framework (MAGF) - A TypeScript framework for building multi-agent systems with governance mechanisms inspired by political science principles (checks and balances, three-tier hierarchy, power balance mechanisms).

**Current Status**: Early development (v0.1.0) - basic infrastructure and type definitions in place, core implementation in progress.

## Essential Commands

### Development
```bash
npm install              # Install dependencies
npm run build            # Build all packages in the monorepo
npm run dev              # Build in watch mode
npm run clean            # Remove all dist/ directories
```

### Code Quality
```bash
npm run typecheck        # TypeScript type checking (no emit)
npm run lint             # ESLint on packages/core/src and packages/cli/src
npm run format           # Prettier formatting
npm run ci               # Run full CI pipeline (lint + typecheck + test)
```

### Testing
```bash
npm test                 # Run all tests with Vitest
npm run test:watch       # Run tests in watch mode
npm run test:coverage    # Generate coverage report (70% threshold required)
```

Test files are located in `packages/*/tests/` or co-located as `*.test.ts` files.

## Architecture Overview

### Three-Tier Governance Structure

The framework implements a hierarchical agent system:

- **Top Layer (3 agents)**: Strategic decisions, conflict arbitration, quality assurance. Implements "three powers separation" concept where roles are dynamically generated by AI based on task requirements.
- **Mid Layer (2-5 agents)**: Domain leadership, task coordination, progress monitoring. Appointed by top layer.
- **Bottom Layer (4-5 agents)**: Task execution, tool invocation, result reporting. Managed by mid layer.

**Critical Design Principle**: Roles are NOT statically predefined. The AI dynamically generates role names and responsibilities based on the specific task context.

### Core Components

1. **Message Bus**: Heartbeat-driven synchronous communication (4-second intervals). All agents process messages at synchronized heartbeat moments, similar to a von Neumann architecture bus.

2. **Whiteboard System**: Markdown-based shared knowledge space. Each layer has its own whiteboard, plus a global whiteboard. Agents can read any whiteboard but can only write to their own layer and the global whiteboard.

3. **Governance Engine**: Implements five power balance mechanisms:
   - Signature: Major decisions require 2-3 signatures
   - Veto: Any authorized party can block decisions
   - Appeal: Vetoed decisions can be appealed to arbitration
   - Accountability: Warning → Demotion → Dismissal for failures
   - Election: Every 50 heartbeats (~3.3 min), agents are evaluated

4. **Persistence**: SQLite database stores task state, agent history, messages, decisions, and audit records.

### Runtime Workspace

The `.agent-workspace/` directory (gitignored) contains:
- `whiteboards/` - Layer-specific and global Markdown files
- `task.db` - SQLite database
- `logs/` - Categorized log files (message bus, audit, performance)

## Key Design Decisions

### Dynamic Role Generation
Unlike traditional multi-agent systems with fixed roles (e.g., "architect", "developer", "tester"), this framework uses AI to generate appropriate roles based on task requirements. A coding task might generate different roles than a research task.

### Heartbeat Synchronization
The 4-second heartbeat cycle ensures predictable system behavior. All agents:
1. Read messages from the bus
2. Execute local computation (plan/execute/reflect)
3. Write output messages to the bus

This simplifies concurrency and makes the system easier to debug.

### Whiteboard Permissions
- Read: Any agent can read any whiteboard
- Write: Agents can only write to their own layer's whiteboard and the global whiteboard
- Cross-layer writes require message bus requests with supervisor approval

## Code Conventions

### TypeScript
- Strict mode enabled with comprehensive type checking
- Use explicit types, avoid `any`
- ES2022 target with ESNext modules
- All code must pass `npm run typecheck` with no errors

### Comments and Documentation
**CRITICAL**: All comments, documentation, and commit messages MUST be in English. This is a strict project requirement from CONTRIBUTING.md.

Use JSDoc for public APIs:
```typescript
/**
 * Calculates performance score for an agent
 *
 * @param metrics - Agent performance metrics
 * @returns Score between 0 and 100
 */
function calculatePerformanceScore(metrics: AgentMetrics): number {
  // Implementation
}
```

### Commit Messages
Follow Conventional Commits format:
```
<type>(<scope>): <subject>

<body>

<footer>
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

Example:
```
feat(core): add message priority queue

Implement priority-based message queue to handle urgent messages
before normal ones. This improves system responsiveness.

Closes #123
```

### Testing
- Minimum 70% coverage required for lines, functions, branches, and statements
- Use Arrange-Act-Assert pattern
- Test files use `.test.ts` extension
- All public APIs must have tests

## Monorepo Structure

```
packages/
├── core/           # @magf/core - Core framework (SDK)
│   ├── src/
│   │   ├── agents/         # Agent base classes
│   │   ├── governance/     # Governance engine
│   │   ├── communication/  # Message bus
│   │   ├── whiteboard/     # Whiteboard system
│   │   ├── persistence/    # Database layer
│   │   ├── types/          # Type definitions
│   │   └── index.ts        # Public API exports
│   └── tests/
├── cli/            # @magf/cli - TUI command-line tool
│   └── src/
└── examples/       # Example implementations (planned)
```

Each package has its own `package.json`, `tsconfig.json`, and `tsup.config.ts`.

## Development Workflow

### Adding New Features
1. Read relevant specification documents in `docs/plans/multi-agent-governance-framework/specs/`
2. Implement in appropriate package (usually `packages/core/`)
3. Add tests with 70%+ coverage
4. Update type definitions if needed
5. Run `npm run ci` to verify
6. Commit with conventional commit format

### Working with Types
Core types are defined in `packages/core/src/types/index.ts`:
- `AgentLayer`: 'top' | 'mid' | 'bottom'
- `AgentStatus`: Enum for agent operational states
- `MessageType`: Enum for inter-agent communication
- `DecisionType`: Types of decisions requiring signatures
- `ExecutionMode`: 'auto' | 'semi-auto'

### Running the CLI (when implemented)
```bash
npx magf start "Create a TODO application"
npx magf status
npx magf pause
npx magf resume
npx magf cancel
```

## Important Notes

- **Node.js Version**: Requires >= 20.0.0
- **Module System**: ES Modules (type: "module" in package.json)
- **Build Tool**: tsup for zero-config TypeScript bundling
- **Test Framework**: Vitest with 10-second timeout
- **Logging**: pino for structured logging (when implemented)
- **Database**: SQLite with better-sqlite3 (when implemented)

## Future Integration

The framework is designed to integrate with the pi-mono ecosystem:
- `@mariozechner/pi-agent-core` - Agent planning/execution/reflection
- `@mariozechner/pi-ai` - LLM integration
- `@mariozechner/pi-coding-agent` - Code generation capabilities

These dependencies are planned but not yet integrated.

## Documentation

Comprehensive planning documents are in `docs/plans/multi-agent-governance-framework/`:
- `master-plan.md` - Overall project vision and roadmap
- `specs/` - Detailed design specifications (14 documents planned)
- `todo/` - Task breakdown for implementation

Refer to these documents when implementing features to ensure alignment with the architectural vision.

## Project Index

This project has a pre-generated index for quick codebase understanding.

- **Location:** `.claude-index/index.md`
- **Last Updated:** 2026-02-11
- **Contents:** Project overview, feature map, file index, exported symbols, module dependencies

**Usage:** Read `.claude-index/index.md` to quickly understand the project structure before making changes. The index provides a navigation map of the codebase without needing to explore every file.

**Regenerate:** Say "regenerate index" or "更新索引" to update the index after major changes.
