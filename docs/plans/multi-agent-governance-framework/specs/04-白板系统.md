# Spec 04: 白板系统设计

## 1. 概述

白板系统是多智能体团队的共享知识空间，使用 Markdown 文件作为存储介质。本文档描述白板的文件结构、权限模型、并发控制、Markdown 规范以及同步机制。

## 2. 白板文件结构

### 2.1 目录布局

```
.agent-workspace/
├── whiteboards/
│   ├── top-layer.md                    # 顶层共享白板
│   ├── mid-layer-{role}.md             # 中层角色白板
│   │   ├── mid-layer-architect.md
│   │   ├── mid-layer-pm.md
│   │   └── mid-layer-qa.md
│   ├── bottom-layer-{id}.md            # 底层 Agent 白板
│   │   ├── bottom-layer-agent-1.md
│   │   ├── bottom-layer-agent-2.md
│   │   └── bottom-layer-agent-3.md
│   └── .locks/                         # 文件锁目录
│       ├── top-layer.lock
│       └── ...
├── global-whiteboard.md                # 全局共享白板
└── whiteboard-history/                 # 历史版本（可选）
    ├── global-whiteboard-v1.md
    ├── global-whiteboard-v2.md
    └── ...
```

### 2.2 白板类型

| 类型 | 路径 | 权限 | 用途 |
|------|------|------|------|
| **全局白板** | `global-whiteboard.md` | 所有 Agent 可读，需权限写 | 任务目标、关键决策、里程碑 |
| **顶层白板** | `whiteboards/top-layer.md` | 顶层可读写，中底层只读 | 战略规划、三权协商记录 |
| **中层白板** | `whiteboards/mid-layer-{role}.md` | 所属中层可读写，上级可读，下级可读 | 领域规划、任务分配 |
| **底层白板** | `whiteboards/bottom-layer-{id}.md` | 所属 Agent 可读写，上级可读 | 任务执行日志、技术细节 |

## 3. 白板内容规范

### 3.1 Markdown 模板

#### 全局白板模板
```markdown
# 全局白板 - {任务名称}

## 任务概述
- **任务ID**: {taskId}
- **创建时间**: {timestamp}
- **执行模式**: 全自动 / 半自动
- **当前状态**: 进行中 / 已完成 / 已取消

## 核心目标
1. {目标1}
2. {目标2}
3. {目标3}

## 关键决策记录
### 决策 #{id}
- **时间**: {timestamp}
- **提议者**: {agentName}
- **内容**: {description}
- **签字方**: {signers}
- **状态**: 已批准 / 被否决 / 申诉中

## 里程碑
- [ ] 里程碑1: {description}
- [ ] 里程碑2: {description}
- [x] 里程碑3: {description} (已完成)

## 团队结构
### 顶层 (3)
- {Top Agent 1}: {role}
- {Top Agent 2}: {role}
- {Top Agent 3}: {role}

### 中层 (N)
- {Mid Agent 1}: {role}
- {Mid Agent 2}: {role}
...

### 底层 (M)
- {Bot Agent 1}: 负责 {task}
- {Bot Agent 2}: 负责 {task}
...

## 问题与风险
- {issue1}
- {issue2}

## 更新日志
- [{timestamp}] {agentName}: {update}
```

#### 层级白板模板
```markdown
# {层级} - {角色名称}

## 基本信息
- **Agent ID**: {id}
- **角色**: {role}
- **职责**: {responsibilities}
- **上级**: {supervisor}
- **下级**: {subordinates}

## 当前任务
### 任务 #{id}
- **描述**: {description}
- **状态**: 进行中 / 已完成
- **进度**: {percentage}%
- **阻塞因素**: {blockers}

## 决策与协商
### 协商记录 #{id}
- **时间**: {timestamp}
- **参与方**: {parties}
- **议题**: {topic}
- **结论**: {conclusion}

## 知识积累
### {知识点1}
{内容}

### {知识点2}
{内容}

## 执行日志
- [{timestamp}] {event}
- [{timestamp}] {event}
```

### 3.2 内容规范

**强制要求**：
1. 使用 UTF-8 编码
2. 每个白板文件大小不超过 10MB
3. 使用标准 Markdown 语法（CommonMark）
4. 时间戳统一使用 ISO 8601 格式

**推荐实践**：
1. 使用标题层级（H1-H4）组织结构
2. 使用列表记录离散信息
3. 使用代码块记录技术细节
4. 使用引用块记录重要决策

## 4. 权限模型

### 4.1 权限矩阵

| Agent 层级 | 全局白板 | 顶层白板 | 中层白板 | 底层白板 |
|-----------|---------|---------|---------|---------|
| **顶层** | 读写 | 读写 | 只读 | 只读 |
| **中层** | 只读 | 只读 | 自己的可读写，其他只读 | 下属的只读 |
| **底层** | 只读 | 只读 | 上级的只读 | 自己的可读写 |

### 4.2 权限检查伪代码

```typescript
class WhiteboardPermissionChecker {
    canRead(agentId: string, whiteboardPath: string): boolean {
        const agent = this.getAgent(agentId)
        const whiteboard = this.parseWhiteboardPath(whiteboardPath)

        // 全局白板：所有人可读
        if (whiteboard.type === 'global') {
            return true
        }

        // 顶层白板：顶层可读，中底层可读
        if (whiteboard.type === 'top-layer') {
            return true // 所有层级都可以读取顶层白板
        }

        // 中层白板
        if (whiteboard.type === 'mid-layer') {
            // 顶层可读
            if (agent.layer === 'top') return true
            // 白板所属中层可读
            if (agent.layer === 'mid' && agent.id === whiteboard.ownerId) return true
            // 其他中层可读
            if (agent.layer === 'mid') return true
            // 底层：仅上级的白板可读
            if (agent.layer === 'bottom' && agent.supervisor === whiteboard.ownerId) return true
            return false
        }

        // 底层白板
        if (whiteboard.type === 'bottom-layer') {
            // 顶层、中层可读
            if (agent.layer === 'top' || agent.layer === 'mid') return true
            // 白板所属底层可读
            if (agent.layer === 'bottom' && agent.id === whiteboard.ownerId) return true
            return false
        }

        return false
    }

    canWrite(agentId: string, whiteboardPath: string): boolean {
        const agent = this.getAgent(agentId)
        const whiteboard = this.parseWhiteboardPath(whiteboardPath)

        // 全局白板：仅顶层可写
        if (whiteboard.type === 'global') {
            return agent.layer === 'top'
        }

        // 顶层白板：仅顶层可写
        if (whiteboard.type === 'top-layer') {
            return agent.layer === 'top'
        }

        // 中层白板：仅白板所属中层可写
        if (whiteboard.type === 'mid-layer') {
            return agent.layer === 'mid' && agent.id === whiteboard.ownerId
        }

        // 底层白板：仅白板所属底层可写
        if (whiteboard.type === 'bottom-layer') {
            return agent.layer === 'bottom' && agent.id === whiteboard.ownerId
        }

        return false
    }

    // 特殊权限：顶层可以向全局白板追加内容
    canAppend(agentId: string, whiteboardPath: string): boolean {
        const agent = this.getAgent(agentId)
        const whiteboard = this.parseWhiteboardPath(whiteboardPath)

        if (whiteboard.type === 'global') {
            return agent.layer === 'top' || agent.layer === 'mid'
        }

        return this.canWrite(agentId, whiteboardPath)
    }
}
```

## 5. 并发控制

### 5.1 文件锁机制

```typescript
interface FileLock {
    lockId: string
    whiteboardPath: string
    agentId: string
    acquiredAt: number
    expiresAt: number
}

class FileLockManager {
    private locks: Map<string, FileLock> = new Map()
    private lockTimeout: number = 5000 // 5 秒超时

    async acquireLock(whiteboardPath: string, agentId: string): Promise<string> {
        // 清理过期锁
        this.cleanupExpiredLocks()

        // 检查是否已被锁定
        const existingLock = this.locks.get(whiteboardPath)
        if (existingLock) {
            if (existingLock.agentId === agentId) {
                // 同一 Agent 重入，延长过期时间
                existingLock.expiresAt = Date.now() + this.lockTimeout
                return existingLock.lockId
            } else {
                throw new Error(`Whiteboard ${whiteboardPath} is locked by ${existingLock.agentId}`)
            }
        }

        // 获取锁
        const lockId = generateUUID()
        const lock: FileLock = {
            lockId,
            whiteboardPath,
            agentId,
            acquiredAt: Date.now(),
            expiresAt: Date.now() + this.lockTimeout
        }

        this.locks.set(whiteboardPath, lock)
        logger.debug(`Lock acquired: ${whiteboardPath} by ${agentId}`)

        return lockId
    }

    releaseLock(lockId: string): void {
        for (const [path, lock] of this.locks) {
            if (lock.lockId === lockId) {
                this.locks.delete(path)
                logger.debug(`Lock released: ${path}`)
                return
            }
        }
    }

    private cleanupExpiredLocks(): void {
        const now = Date.now()
        for (const [path, lock] of this.locks) {
            if (lock.expiresAt < now) {
                this.locks.delete(path)
                logger.warn(`Lock expired and cleaned up: ${path}`)
            }
        }
    }
}
```

### 5.2 乐观锁（版本号）

```typescript
interface WhiteboardMetadata {
    path: string
    version: number
    lastModifiedBy: string
    lastModifiedAt: number
}

class OptimisticLockManager {
    private metadata: Map<string, WhiteboardMetadata> = new Map()

    getVersion(whiteboardPath: string): number {
        return this.metadata.get(whiteboardPath)?.version || 0
    }

    async writeWithVersionCheck(
        whiteboardPath: string,
        content: string,
        expectedVersion: number,
        agentId: string
    ): Promise<void> {
        const currentVersion = this.getVersion(whiteboardPath)

        if (currentVersion !== expectedVersion) {
            throw new Error(`Version conflict: expected ${expectedVersion}, got ${currentVersion}`)
        }

        // 写入文件
        await fs.writeFile(whiteboardPath, content, 'utf-8')

        // 更新元数据
        this.metadata.set(whiteboardPath, {
            path: whiteboardPath,
            version: currentVersion + 1,
            lastModifiedBy: agentId,
            lastModifiedAt: Date.now()
        })

        logger.info(`Whiteboard updated: ${whiteboardPath} v${currentVersion + 1} by ${agentId}`)
    }
}
```

## 6. 白板系统实现

### 6.1 WhiteboardSystem 类

```typescript
class WhiteboardSystem {
    private config: WhiteboardConfig
    private permissionChecker: WhiteboardPermissionChecker
    private lockManager: FileLockManager
    private optimisticLockManager: OptimisticLockManager
    private cache: Map<string, { content: string, cachedAt: number }> = new Map()
    private cacheTimeout: number = 2000 // 2 秒缓存

    constructor(config: WhiteboardConfig) {
        this.config = config
        this.permissionChecker = new WhiteboardPermissionChecker()
        this.lockManager = new FileLockManager()
        this.optimisticLockManager = new OptimisticLockManager()
    }

    // === 读取操作 ===

    async read(layer: string, agentId?: string): Promise<string> {
        const whiteboardPath = this.resolveWhiteboardPath(layer, agentId)

        // 权限检查
        if (!this.permissionChecker.canRead(this.getCurrentAgentId(), whiteboardPath)) {
            throw new Error(`Permission denied: cannot read ${whiteboardPath}`)
        }

        // 检查缓存
        const cached = this.cache.get(whiteboardPath)
        if (cached && Date.now() - cached.cachedAt < this.cacheTimeout) {
            return cached.content
        }

        // 读取文件
        try {
            const content = await fs.readFile(whiteboardPath, 'utf-8')
            this.cache.set(whiteboardPath, { content, cachedAt: Date.now() })
            return content
        } catch (error) {
            if (error.code === 'ENOENT') {
                // 文件不存在，返回空模板
                return this.getTemplate(layer)
            }
            throw error
        }
    }

    // === 写入操作 ===

    async write(layer: string, content: string, agentId: string): Promise<void> {
        const whiteboardPath = this.resolveWhiteboardPath(layer, agentId)

        // 权限检查
        if (!this.permissionChecker.canWrite(agentId, whiteboardPath)) {
            throw new Error(`Permission denied: cannot write ${whiteboardPath}`)
        }

        // 获取文件锁
        const lockId = await this.lockManager.acquireLock(whiteboardPath, agentId)

        try {
            // 使用乐观锁写入
            const currentVersion = this.optimisticLockManager.getVersion(whiteboardPath)
            await this.optimisticLockManager.writeWithVersionCheck(
                whiteboardPath,
                content,
                currentVersion,
                agentId
            )

            // 清除缓存
            this.cache.delete(whiteboardPath)

            // 通知其他 Agent 白板更新
            this.emitWhiteboardUpdate(whiteboardPath, agentId)

        } finally {
            // 释放锁
            this.lockManager.releaseLock(lockId)
        }
    }

    // === 追加操作 ===

    async append(layer: string, content: string, agentId: string): Promise<void> {
        const whiteboardPath = this.resolveWhiteboardPath(layer, agentId)

        // 权限检查
        if (!this.permissionChecker.canAppend(agentId, whiteboardPath)) {
            throw new Error(`Permission denied: cannot append to ${whiteboardPath}`)
        }

        const lockId = await this.lockManager.acquireLock(whiteboardPath, agentId)

        try {
            // 读取现有内容
            const existingContent = await this.read(layer, agentId)

            // 追加内容（添加时间戳和署名）
            const newContent = existingContent + '\n\n' +
                `### 更新 - ${new Date().toISOString()}\n` +
                `**操作者**: ${agentId}\n\n` +
                content

            // 写入
            await this.write(layer, newContent, agentId)

        } finally {
            this.lockManager.releaseLock(lockId)
        }
    }

    // === 辅助方法 ===

    private resolveWhiteboardPath(layer: string, agentId?: string): string {
        if (layer === 'global') {
            return path.join(this.config.workspacePath, 'global-whiteboard.md')
        }

        if (layer === 'top') {
            return path.join(this.config.workspacePath, 'whiteboards', 'top-layer.md')
        }

        if (layer === 'mid' && agentId) {
            const role = this.getAgentRole(agentId)
            return path.join(this.config.workspacePath, 'whiteboards', `mid-layer-${role}.md`)
        }

        if (layer === 'bottom' && agentId) {
            return path.join(this.config.workspacePath, 'whiteboards', `bottom-layer-${agentId}.md`)
        }

        throw new Error(`Invalid whiteboard path: layer=${layer}, agentId=${agentId}`)
    }

    private getTemplate(layer: string): string {
        // 返回对应层级的 Markdown 模板
        switch (layer) {
            case 'global':
                return GLOBAL_WHITEBOARD_TEMPLATE
            case 'top':
                return TOP_LAYER_WHITEBOARD_TEMPLATE
            case 'mid':
                return MID_LAYER_WHITEBOARD_TEMPLATE
            case 'bottom':
                return BOTTOM_LAYER_WHITEBOARD_TEMPLATE
            default:
                return '# 白板\n\n'
        }
    }

    private emitWhiteboardUpdate(whiteboardPath: string, agentId: string): void {
        // 发送事件通知（可选）
        eventEmitter.emit('whiteboard:updated', {
            path: whiteboardPath,
            updatedBy: agentId,
            timestamp: Date.now()
        })
    }
}
```

## 7. Markdown 解析与渲染

### 7.1 解析器

```typescript
import { marked } from 'marked'

class WhiteboardParser {
    parse(markdown: string): WhiteboardAST {
        const tokens = marked.lexer(markdown)
        return this.buildAST(tokens)
    }

    private buildAST(tokens: marked.Token[]): WhiteboardAST {
        const sections: WhiteboardSection[] = []
        let currentSection: WhiteboardSection | null = null

        for (const token of tokens) {
            if (token.type === 'heading' && token.depth === 2) {
                if (currentSection) {
                    sections.push(currentSection)
                }
                currentSection = {
                    title: token.text,
                    content: [],
                    subsections: []
                }
            } else if (currentSection) {
                currentSection.content.push(token)
            }
        }

        if (currentSection) {
            sections.push(currentSection)
        }

        return { sections }
    }

    extractDecisions(ast: WhiteboardAST): Decision[] {
        const decisionsSection = ast.sections.find(s => s.title === '关键决策记录')
        if (!decisionsSection) return []

        // 解析决策列表
        const decisions: Decision[] = []
        // ... 解析逻辑
        return decisions
    }

    extractMilestones(ast: WhiteboardAST): Milestone[] {
        const milestonesSection = ast.sections.find(s => s.title === '里程碑')
        if (!milestonesSection) return []

        // 解析里程碑
        const milestones: Milestone[] = []
        // ... 解析逻辑
        return milestones
    }
}
```

### 7.2 渲染器（TUI 显示）

```typescript
import chalk from 'chalk'

class WhiteboardRenderer {
    renderForTUI(markdown: string): string {
        const ast = new WhiteboardParser().parse(markdown)
        let output = ''

        for (const section of ast.sections) {
            output += chalk.bold.cyan(`\n## ${section.title}\n`)

            for (const item of section.content) {
                output += this.renderToken(item)
            }
        }

        return output
    }

    private renderToken(token: marked.Token): string {
        switch (token.type) {
            case 'list':
                return this.renderList(token)
            case 'paragraph':
                return token.text + '\n\n'
            case 'code':
                return chalk.gray(token.text) + '\n'
            default:
                return ''
        }
    }

    private renderList(token: marked.Tokens.List): string {
        let output = ''
        for (const item of token.items) {
            const checkbox = item.checked !== undefined
                ? (item.checked ? chalk.green('✓') : chalk.gray('☐'))
                : '-'
            output += `${checkbox} ${item.text}\n`
        }
        return output + '\n'
    }
}
```

## 8. 历史版本管理（可选）

```typescript
class WhiteboardVersionControl {
    private maxVersions: number = 10

    async saveVersion(whiteboardPath: string, content: string): Promise<void> {
        const versionDir = path.join(path.dirname(whiteboardPath), 'whiteboard-history')
        await fs.mkdir(versionDir, { recursive: true })

        const basename = path.basename(whiteboardPath, '.md')
        const timestamp = Date.now()
        const versionPath = path.join(versionDir, `${basename}-${timestamp}.md`)

        await fs.writeFile(versionPath, content, 'utf-8')

        // 清理旧版本
        await this.cleanupOldVersions(versionDir, basename)
    }

    async listVersions(whiteboardPath: string): Promise<string[]> {
        const versionDir = path.join(path.dirname(whiteboardPath), 'whiteboard-history')
        const basename = path.basename(whiteboardPath, '.md')

        const files = await fs.readdir(versionDir)
        return files
            .filter(f => f.startsWith(basename))
            .sort()
            .reverse()
    }

    async restoreVersion(whiteboardPath: string, versionFile: string): Promise<void> {
        const versionDir = path.join(path.dirname(whiteboardPath), 'whiteboard-history')
        const versionPath = path.join(versionDir, versionFile)

        const content = await fs.readFile(versionPath, 'utf-8')
        await fs.writeFile(whiteboardPath, content, 'utf-8')

        logger.info(`Restored whiteboard from ${versionFile}`)
    }

    private async cleanupOldVersions(versionDir: string, basename: string): Promise<void> {
        const files = await fs.readdir(versionDir)
        const versionFiles = files.filter(f => f.startsWith(basename)).sort().reverse()

        if (versionFiles.length > this.maxVersions) {
            const toDelete = versionFiles.slice(this.maxVersions)
            for (const file of toDelete) {
                await fs.unlink(path.join(versionDir, file))
            }
        }
    }
}
```

## 9. 性能优化

### 9.1 内存缓存

```typescript
class WhiteboardCache {
    private cache: LRUCache<string, string>

    constructor(maxSize: number = 50) {
        this.cache = new LRUCache({ max: maxSize })
    }

    get(key: string): string | undefined {
        return this.cache.get(key)
    }

    set(key: string, value: string): void {
        this.cache.set(key, value)
    }

    invalidate(key: string): void {
        this.cache.delete(key)
    }

    clear(): void {
        this.cache.clear()
    }
}
```

### 9.2 增量更新

```typescript
class IncrementalWhiteboardUpdater {
    async appendSection(whiteboardPath: string, sectionTitle: string, content: string): Promise<void> {
        // 只追加新内容，不重写整个文件
        const newSection = `\n## ${sectionTitle}\n${content}\n`
        await fs.appendFile(whiteboardPath, newSection, 'utf-8')
    }

    async updateSection(whiteboardPath: string, sectionTitle: string, newContent: string): Promise<void> {
        // 读取文件
        const fullContent = await fs.readFile(whiteboardPath, 'utf-8')

        // 定位目标 section
        const sectionRegex = new RegExp(`## ${sectionTitle}[\\s\\S]*?(?=##|$)`)
        const updatedContent = fullContent.replace(sectionRegex, `## ${sectionTitle}\n${newContent}\n`)

        // 写回文件
        await fs.writeFile(whiteboardPath, updatedContent, 'utf-8')
    }
}
```

## 10. 测试策略

```typescript
describe('WhiteboardSystem', () => {
    it('should enforce read permissions', async () => {
        const system = new WhiteboardSystem(config)

        // 底层 Agent 不能读取其他底层的白板
        await expect(
            system.read('bottom', 'agent-2') // 当前 Agent 是 agent-1
        ).rejects.toThrow('Permission denied')
    })

    it('should handle concurrent writes with locks', async () => {
        const system = new WhiteboardSystem(config)

        const writes = [
            system.write('global', 'Content A', 'agent-1'),
            system.write('global', 'Content B', 'agent-2')
        ]

        // 应该串行执行，不会冲突
        await Promise.all(writes)

        const content = await system.read('global')
        expect(content).toMatch(/Content (A|B)/)
    })
})
```

## 11. 总结

白板系统设计确保了：
- **清晰的权限模型**：不同层级有明确的读写权限
- **健壮的并发控制**：文件锁 + 乐观锁双重保障
- **灵活的 Markdown 格式**：易于人工阅读和 LLM 理解
- **高效的缓存机制**：减少磁盘 I/O
- **可选的版本管理**：支持历史回溯

下一步将详细设计权力制衡、动态角色生成等治理机制。
